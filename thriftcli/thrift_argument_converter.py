import json
import sys

from .thrift_cli_error import ThriftCLIError
from .thrift_parser import ThriftParser


class ThriftArgumentConverter(object):
    """ Converts a json request body into the corresponding Python object generated by thrift. """

    def __init__(self, thrift_path, thrift_dir_paths=None):
        thrift_parser = ThriftParser(thrift_path, thrift_dir_paths)
        self._parse_result = thrift_parser.parse()

    def convert_args(self, service_reference, method_name, data):
        """ Converts json request body into keyword arguments for a service's method.

        :param service_reference: Name of the service that provides the given method.
        :type service_reference: str
        :param method_name: Name of the method whose type signature is the basis for the conversion.
        :type method_name: str
        :param data: The json request body, mapping argument names to their values.
        :type data: dict
        :returns: Keyword argument dictionary representing the request body.
        :rtype: dict

        """
        fields = self._parse_result.get_fields_for_endpoint(service_reference, method_name)
        return self._convert_json_to_args_given_fields(fields, data)

    def _convert_json_to_args_given_fields(self, fields, data):
        """ Converts a request body into a Python object, given the fields each key value pair should convert into. """
        args = {field_name: self._convert_json_entry_to_arg(fields[field_name].field_type, value)
                for field_name, value in data.items()}
        return args

    def _convert_json_entry_to_arg(self, field_type, value):
        """ Converts a request body item into an argument for the Python object. """
        field_type = self._parse_result.unalias_type(field_type)
        if self._parse_result.get_struct(field_type) is not None:
            fields = self._parse_result.get_fields_for_struct_name(field_type)
            value = self._convert_json_to_args_given_fields(fields, value)
        arg = self._construct_arg(field_type, value)
        return arg

    def _construct_arg(self, field_type, value):
        """ Converts a simple request body item into an argument for the Python object.

        A request body item is simple when it is not a struct that has another struct as a field. """
        if self._parse_result.get_struct(field_type) is not None:
            return self._construct_struct_arg(field_type, value)
        elif self._parse_result.has_enum(field_type):
            return self._construct_enum_arg(field_type, value)
        elif field_type.startswith('list<'):
            return self._construct_list_arg(field_type, value)
        elif field_type.startswith('set<'):
            return self._construct_set_arg(field_type, value)
        elif field_type.startswith('map<'):
            return self._construct_map_arg(field_type, value)
        elif field_type == 'string':
            return str(value)
        elif field_type == 'double':
            return float(value)
        elif field_type == 'bool':
            return bool(value)
        try:
            return long(value)
        except ValueError:
            return value

    @staticmethod
    def _get_type_class(package, type_name):
        """ Gets the generated Python class corresponding to a type definition. """
        return getattr(sys.modules['%s.ttypes' % package], type_name)

    @staticmethod
    def _construct_struct_arg(field_type, value):
        """ Returns the Python object corresponding to a struct. """
        package, struct = ThriftArgumentConverter._split_field_type(field_type)
        constructor = ThriftArgumentConverter._get_type_class(package, struct)
        return constructor(**value)

    @staticmethod
    def _construct_enum_arg(field_type, value):
        """ Returns the value corresponding to an enum. """
        package, enum = ThriftArgumentConverter._split_field_type(field_type)
        enum_class = ThriftArgumentConverter._get_type_class(package, enum)
        if isinstance(value, (int, long)):
            return value
        elif isinstance(value, basestring):
            return enum_class._NAMES_TO_VALUES[value]
        raise ThriftCLIError('Invalid value provided for enum %s: %s' % (field_type.str(value)))

    def _construct_list_arg(self, field_type, value):
        """ Returns the Python list corresponding to a JSON array in the request body. """
        elem_type = field_type[field_type.index('<') + 1: field_type.rindex('>')]
        return tuple([self._convert_json_entry_to_arg(elem_type, elem) for elem in value])

    def _construct_set_arg(self, field_type, value):
        """ Returns the Python set corresponding to a JSON array in the request body. """
        elem_type = field_type[field_type.index('<') + 1: field_type.rindex('>')]
        return frozenset([self._convert_json_entry_to_arg(elem_type, elem) for elem in value])

    def _construct_map_arg(self, field_type, value):
        """ Returns the Python dict corresponding to a JSON object in the request body. """
        types_string = field_type[field_type.index('<') + 1: field_type.rindex('>')]
        split_index = ThriftParser.calc_map_types_split_index(types_string)
        if split_index == -1:
            raise ThriftCLIError('Invalid type formatting for map - \'%s\'' % types_string)
        key_type = types_string[:split_index].strip()
        elem_type = types_string[split_index + 1:].strip()
        prep = lambda x: x if self._parse_result.get_struct(key_type) is None else json.loads(x)
        return {self._convert_json_entry_to_arg(key_type, prep(key)): self._convert_json_entry_to_arg(elem_type, elem)
                for key, elem in value.items()}

    @staticmethod
    def _split_field_type(field_type):
        """ Extracts the namespace and type name from a field type. """
        split = field_type.split('.')
        if not split or len(split) != 2:
            raise ThriftCLIError('Field type should be in format \'Namespace.type\', given \'%s\'' % field_type)
        return split
